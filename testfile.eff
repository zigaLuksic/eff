
effect Ping : int -> bool

let h : (unit!{Ping} => bool!{}) = handler
  | effect Ping x k -> true
  | val x -> false

let test1 = with h handle !Ping 2; ()



let f : int -> int!{} = fun x -> x

let (g : int -> int!{} ) x = 1

let rec (pinger : int list -> unit!{Ping}) = function
  | [] -> ()
  | x :: xs -> !Ping x; pinger xs  

effect Get : unit -> int
effect Set : int -> unit

let state_handler : int!{Get,Set} => int -> (int * int) = handler
  | effect Get () k -> (fun s -> k s s)
  | effect Set s k -> (fun _ -> k () s)
  | val x -> (fun s -> (x, s))

let test2 = with state_handler handle !Set(10 + !Get ()); !Get () + 2



let rec (int_foldl 
  : (int -> int -> int) -> int -> int list -> int)
  f acc = function
  | [] -> acc
  | x :: xs -> int_foldl f (f acc x) xs

let list_prod = int_foldl ( * ) 1

let test3 = list_prod [1;2;3]



type 'a tree = Empty | Node of 'a tree * 'a * 'a tree

effect Yield : int -> unit

let rec (tree_yield : int tree -> unit!{Yield}) = function
  | Empty -> ()
  | Node (lt, x, rt) -> tree_yield lt; !Yield x; tree_yield rt

let yield_sum : unit!{Yield} => int = handler
  | effect Yield x k -> x + k ()
  | val () -> 0

let leaf : int -> int tree = fun x -> Node (Empty, x, Empty)

let test_tree : int tree = (Node (leaf 1, 5, Node (leaf 4, 2, leaf 0)))

let test4 = with yield_sum handle tree_yield test_tree
