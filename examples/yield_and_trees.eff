(* Just a short example to check that type definitions work. *)

(* Custom types allow subtyping, but the user must mark in the definition.
   Use `+'a` for covariant parameters, `-'b` for contravariant ones and `'c`
   for fixed parameters. The type system checks that parameters fit. *)
type +'a tree = Empty | Node of 'a tree * 'a * 'a tree

(* This one fails because the second parameter is marked as contravariant
   but is also present in a covariant position. Changing it to `'b`
   resolves the issue. *)

(* type ('a, -'b) test = A of 'a | B of 'b -> 'a | C of 'a -> 'a * 'b *)

(* Type variables are allowed in definitions but not annotations. Therefore
   the type system refuses to work with data types such as lists without
   unless a specific type is provided. The term `Empty` can only be used
   if it is clear what 'a is. *)

(* Tree traversal *)
effect Yield : int -> unit

let rec (tree_yield : int tree -> unit!{Yield}) = function
  | Empty -> ()
  | Node (lt, x, rt) -> tree_yield lt; !Yield x; tree_yield rt

let rec (cond_tree_yield : (int -> bool) -> int tree -> unit!{Yield}) cond tree =
  let cond_yield : int -> unit!{Yield} = 
    (* Conditionals branch and want annotations *)
    fun x -> if cond x then !Yield x else () 
  in
  match tree with
  | Empty -> ()
  | Node (lt, x, rt) -> 
      cond_tree_yield cond lt; cond_yield x ; cond_tree_yield cond rt



(* Handlers *)
let yield_sum : unit!{Yield} => int = handler
  | effect Yield x k -> x + k ()
  | val () -> 0

let yield_to_list : unit!{Yield} => int list = handler
  | effect Yield x k -> x :: k ()
  | val () -> []



(* Tests *)
let leaf : int -> int tree = fun x -> Node (Empty, x, Empty)

let test_tree : int tree = (Node (leaf 1, 5, Node (leaf 4, 2, leaf 0)))

let test1 = with yield_sum handle tree_yield test_tree

let test2 = 
  with yield_to_list handle 
    cond_tree_yield (fun x -> x > 2) test_tree
