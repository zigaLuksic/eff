(* This example is described in Section 6.8 of "Programming with Algebraic Effects and
   Handlers" by A. Bauer and M. Pretnar. *)

(* A version of ambivalent choice which tells how it found the desired value. *)
type int_opt = None | Some of int
type int_list = Nil | Cons of int * int_list
type assoc = Empty | Link of string * int * assoc

type result = Failure | Success of assoc

(* Select_int takes a variable name and a list of possible integer choices
   and chooses one. *)

effect Select_int: (string * int_list) -> int

external ( = ) : string -> (string -> bool!{})!{} = "="
external ( == ) : int -> (int -> bool!{})!{} = "="


(* The handler tries out all choices until it finds one that leads to the
   desired outcome. All current choices are saved in an association list. *)


let rec (assoc : string -> (assoc -> int_opt!{})!{}) name = function
  | Empty -> None
  | Link(k, v, tl) -> if k = name then Some v else assoc name tl 

let rec (selection_collector : 
    int -> (int!{Select_int}=>(assoc -> result!{})!{})!{})
  desired_outcome = handler
  | effect Select_int (name, choices) k -> (fun selected ->
    (* Check association list if variable already chosen. *)
    (match assoc name selected with
     | Some y -> (k y) selected
     | None ->
       (* Select a value and try to get desired outcome. *)
         let rec (try_choice : int_list -> result!{}) = function
           | Nil -> Failure
           | Cons(y, ys) ->
               (match (k y) (Link (name, y, selected)) with
                  | Success lst -> Success lst
                  | Failure -> try_choice ys)
         in try_choice choices))
  | outcome -> (fun selected ->
    (* Check if outcome is the desired one. *)
    if outcome == desired_outcome then Success selected else Failure)
  (* Because we are passing a state, we need to start with an empty assoc list.*)
;;

external ( + ) : int -> (int -> int!{})!{} = "+"

external ( * ) : int -> (int -> int!{})!{} = "*"
;;

(* Search for a Pythagorean triple. It finds a=5, b=12, c=13. *)
with selection_collector 350 handle
  let a = !Select_int ("a", Cons(5, Cons (6, Cons(7, Cons(8, Nil))))) in
  let b = !Select_int ("b", Cons(9, Cons (10, Cons(1, Cons(12, Nil))))) in
  let c = !Select_int ("c", Cons(13, Cons (14, Cons(1, Cons(16, Nil))))) in
  let rec (comp : unit -> int!{Select_int}) () = a*a + b*b + c*c in
  comp ();;